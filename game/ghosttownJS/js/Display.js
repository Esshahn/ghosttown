// Generated by CoffeeScript 1.10.0
var Display,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Display = (function() {
  function Display() {
    this.renderloop = bind(this.renderloop, this);
    this.use_crt_shader = true;
    if (!this.use_crt_shader) {
      this.renderer = new PIXI.autoDetectRenderer(CANVAS_WIDTH, CANVAS_HEIGHT, {
        backgroundColor: COLOR_BLACK
      });
      document.getElementById("game").appendChild(this.renderer.view);
    } else {
      this.renderer = new PIXI.CanvasRenderer(CANVAS_WIDTH, CANVAS_HEIGHT, {
        backgroundColor: COLOR_BLACK
      });
      crtEmulator.init(this.renderer.view, "game");
      this.crt_emulation = true;
      if (this.crt_emulation === true) {
        crtEmulator.scanlines = true;
        crtEmulator.gaussian = 0.6;
        crtEmulator.light = 8;
        crtEmulator.curvature = true;
        crtEmulator.gamma = 0.8;
        crtEmulator.contrast = 0.9;
        crtEmulator.saturation = 0.8;
        crtEmulator.brightness = 1.6;
      } else {
        crtEmulator.scanlines = crtEmulator.curvature = false;
        crtEmulator.gaussian = crtEmulator.light = 0;
        crtEmulator.gamma = crtEmulator.contrast = crtEmulator.saturation = crtEmulator.brightness = 1;
      }
    }
    this.stage = new PIXI.Container;
    this.screen = new PIXI.Container;
    this.screen.position.x = LEFT_BORDER;
    this.screen.position.y = TOP_BORDER;
    this.screen.scale.set(SCALE_FACTOR, SCALE_FACTOR);
    this.stage.addChild(this.screen);
  }

  Display.prototype.change_screen_colors = function(masktype, bordercolor, screencolor) {
    var size_limit;
    if (masktype == null) {
      masktype = "game";
    }
    this.clear();
    size_limit = masktype === "game" ? 8 : 0;
    this.mask = new PIXI.Graphics;
    this.mask.beginFill();
    this.mask.drawRect(LEFT_BORDER, TOP_BORDER, (SCREEN_WIDTH - size_limit) * SCALE_FACTOR, (SCREEN_HEIGHT - size_limit) * SCALE_FACTOR);
    this.mask.endFill();
    this.screen.mask = this.mask;
    this.renderer.backgroundColor = bordercolor;
    this.screen_color = new PIXI.Graphics;
    this.screen_color.beginFill(screencolor);
    this.screen_color.drawRect(0, 0, (SCREEN_WIDTH - size_limit) * SCALE_FACTOR, (SCREEN_HEIGHT - size_limit) * SCALE_FACTOR);
    this.screen_color.endFill();
    return this.screen.addChild(this.screen_color);
  };

  Display.prototype.show_data = function(charset) {
    if (charset == null) {
      charset = charset_game;
    }
    this.level_data = room.get();
    this.change_screen_colors("game", COLOR_RED, COLOR_BLACK);
    return this.create_level_data(this.level_data, charset);
  };

  Display.prototype.show_death = function(msg_number, charset) {
    if (charset == null) {
      charset = charset_commodore;
    }
    this.level_data = room.playround_data.all_msg.screen_data[msg_number];
    this.change_screen_colors("full", COLOR_BLUE, COLOR_BLUE);
    return this.create_level_data(this.level_data, charset);
  };

  Display.prototype.show_msg = function(msg_number, charset) {
    if (charset == null) {
      charset = charset_hint;
    }
    this.level_data = room.playround_data.all_msg.screen_data[msg_number];
    this.change_screen_colors("full", COLOR_RED, COLOR_BLACK);
    return this.create_level_data(this.level_data, charset);
  };

  Display.prototype.show_other = function(msg_number, charset, color) {
    var screencolor;
    if (charset == null) {
      charset = charset_commodore;
    }
    if (color == null) {
      color = COLOR_YELLOW;
    }
    this.level_data = room.playround_data.all_other.screen_data[msg_number];
    screencolor = color;
    if (msg_number === 2) {
      screencolor = COLOR_BLACK;
    }
    this.change_screen_colors("full", color, screencolor);
    return this.create_level_data(this.level_data, charset);
  };

  Display.prototype.create_level_data = function(level_data, charset) {
    var i, level_sprites, results, xpos, ypos;
    this.level_data = level_data;
    level_sprites = [];
    xpos = 0;
    ypos = 0;
    i = 0;
    results = [];
    while (i < this.level_data.length) {
      level_sprites[i] = new PIXI.Sprite(charset[this.level_data[i]]);
      if (xpos >= SCREEN_WIDTH) {
        xpos = 0;
        ypos += 8;
      }
      level_sprites[i].position.x = xpos;
      level_sprites[i].position.y = ypos;
      this.screen.addChild(level_sprites[i]);
      xpos += 8;
      results.push(i++);
    }
    return results;
  };

  Display.prototype.clear = function() {
    var i, results;
    i = this.screen.children.length - 1;
    results = [];
    while (i >= 0) {
      this.screen.removeChild(this.screen.children[i]);
      results.push(i--);
    }
    return results;
  };

  Display.prototype.addElement = function(element) {
    return this.screen.addChild(element);
  };

  Display.prototype.toggleCRT = function() {
    if (this.use_crt_shader) {
      if (this.crt_emulation === false) {
        this.crt_emulation = true;
        crtEmulator.scanlines = true;
        crtEmulator.gaussian = 0.6;
        crtEmulator.light = 8;
        crtEmulator.curvature = true;
        crtEmulator.gamma = 0.8;
        crtEmulator.contrast = 0.9;
        crtEmulator.saturation = 0.8;
        return crtEmulator.brightness = 1.6;
      } else {
        this.crt_emulation = false;
        crtEmulator.scanlines = crtEmulator.curvature = false;
        crtEmulator.gaussian = crtEmulator.light = 0;
        return crtEmulator.gamma = crtEmulator.contrast = crtEmulator.saturation = crtEmulator.brightness = 1;
      }
    }
  };

  Display.prototype.renderloop = function() {
    this.renderer.render(this.stage);
    if (this.use_crt_shader) {
      crtEmulator.updateFrame();
    }
    requestAnimationFrame(this.renderloop);
  };

  return Display;

})();

//# sourceMappingURL=Display.js.map
